# Array vs Linked List

리스트를 구현하는 두 가지 방법: array와 linked list의 차이

→ Array는 크기가 정해져있고, 물리적인 주소가 순차적이다. 인덱스를 가지고 있어 검색이 빠르다. 그러나 삽입/삭제는 불편하다.

→ 연결리스트는 크기가 정해져있지 않고 물리적 주소가 순차적이지 않다. 검색이 느리지만 삽입/삭제가 편하다.

# Hash

- **hash란?**
    - 해시란 데이터를 다루는 기법 중 하나로 검색과 저장이 매우 빠르다.
    - 특정한 값을 검색하는데 데이터 고유의 인덱스로 접근하게 되므로 average case에 대한 시간복잡도가 O(1)이 된다.
    - 문제: 인덱스로 저장되는 key 값이 불규칙함 → 해결: 저장할 데이터와 연관된 고유한 숫자를 만들어 인덱스로 사용한다. → 해시 함수(Hash Function)
- **Hash Function**
    - 저장되는 값들의 key 값을 작은 범위의 값들로 바꿔주는 함수
- Q. hash table이란?
- Q. hash 충돌이란? collision
    - 서로 다른 두 개의 키가 같은 인덱스로 hashing 되면 같은 곳에 저장할 수 없게 되는 것
- Q. 해시테이블에서 해시 충돌을 회피하는 2가지 기법 - Resolve Collision
    1. **Open Address 방식 - 개방주소법**
        - 한 공간에 들어갈 수 있는 개수가 제한되어 있다.
        1. Linear Probing 선형 탐사
            - 해시 충돌 시 비어있는 공간이 나올 때까지 1씩 이동하여 데이터를 삽입한다.
            - primary clustering 문제가 있다. 한 번 충돌하기 시작하면 해당
        2. Quadratic Probing 제곱 탐사
            - 해시 충돌 시 제곱만큼 건너뛰어 데이터를 삽입한다.
        3. Double Hashing 이중 해싱
            - 해시 충돌 시 다른 해시 함수를 한 번 더 적용한 결과를 이용한다.
    2. **Separate Chaining 방식 - 분리연결법**
        - 한 공간에 들어갈 수 있는 개수를 제한하지 않고 Linked List로 만들어 계속 key값을 추가하며 Hash Table에 담는 방법
        - (+) 구현이 간단하다. Hash Table의 포화상태가 없다.
        - (-) 메모리가 낭비된다. 체인의 길이가 너무 길어지면 탐색이 O(n)이 되어 Hash의 장점을 살리지 못한다. 캐쉬 성능이 저하된다.

# Graph

- Q. 그래프란 무엇인가?
    - 그래프란 연결되어 있는 데이터 간의 관계를 설명하는 자료구조이다
- Q. 트리 / 그래프 차이
    - 트리:
        - 그래프의 한 종류
        - 여러 노드가 한 노드를 가리킬 수 없음.
        - 한 개의 루트 노드를 가진다.
        - 사이클이 허용되지 않는 그래프를 말함.
    - 그래프:
        - 2개 이상의 경로가 가능하다.
        - 노드들 사이에 무방향/방향에서 양방향 경로를 가질 수 있다.
        - 루트노드, 부모-자식 관계 개념이 없다.
- Q. dfs / bfs 차이
    - **DFS** 깊이우선:
        - 그래프 상의 한 정점으로부터 한 쪽 방향으로 더이상 갈 수 없을 때까지 진행한 후, 가장 가까운 (intersection) 교차지점으로 돌아가 서치를 계속한다
        - 스택/재귀함수로 구현한다
        - 시간복잡도 O(V+E)
    - **BFS** 너비우선:
        - 가까운 인접 노드부터 탐색, 멀리 떨어져있는 노드를 나중에 탐색하는 방법
        - 큐로 구현한다
- Q. 그래프를 인접리스트 / 인접행렬 구현 시 차이, 장단점, 쓰이는 상황
    
    인접행렬:
    
    - (+) 두 정점을 연결하는 간선 조회 시간복잡도 O(1)
    - (-) 간선의 수와 무관하게 항상 n² 크기의 2차원 배열이 필요하므로 메모리 공간이 낭비된다.
    - (-) 그래프의 모든 간선의 수를 알아내려면 인접행렬 전체를 확인해야 하므로 O(n²)의 시간이 소요된다.
- Graph 용어 정리
    - Undirected Graph: 정점과 간선의 연결관계에서 **방향성이 없는** 그래프
    - Directed Graph(Digraph): 간선에 **방향성이 포함되어 있는** 그래프
    - Degree
        - Undirected Graph에서) 각 정점(Vertex)에 연결된 Edge의 개수
        - Directed Graph에서) 각 정점으로부터 나가는 간선의 개수 - Outdegree / 들어오는 간선의 개수 - Indegree
    - Weight Graph 가중치 그래프
        - 간선에 가중치 정보를 두어 구성한 그래프
        - cf) 비가중치 그래프: 모든 간선의 가중치가 동일한 그래프
    - Sub Graph 부분 그래프
        - 본래의 그래프의 일부 정점 및 간선으로 이루어진 그래프
- Graph 구현
    - 인접 행렬 adjacent matrix: 정방 행렬을 사용하는 방법
        - (+) 해당하는 위치의 value 값을 통해 vertex 간의 연결 관계를 O(1)으로 파악할 수 있다. = 두 정점을 연결하는 간선을 조회하는 시간복잡도는 O(1)이다.
        - 간선 Edge의 개수와는 무관하게 V²의 공간복잡도를 갖는다.
            - (-) 항상 V²크기의 2차원 배열이 필요하므로 메모리 공간이 낭비될 수 있다.
        - Dense Graph를 표현할 때 적절한 방법이다.
    - 인접 리스트 adjacent list: 연결 리스트를 사용하는 방법
        - vertex의 adjacent list를 확인해봐야 하므로 vertex간 연결되어있는지 확인하는데 오래 걸린다.
        - 공간복잡도 O(E+V)
        - Sparse Graph를 표현할 때 적절한 방법이다.
- Graph 탐색
    - DFS, BFS
- Minimum Spanning Tree (MST)
    - Minimum Spanning Tree란:
        - 그래프 G의 Spanning Tree 중 edge weight의 합이 최소인 spanning tree를 말한다.
        - 여기에서 spanning tree란 그래프 G의 모든 vertex가 사이클 없이 연결된 형태를 말한다.
    - **Kruskal Algorithm 크루스칼 알고리즘**
        - 각 단계에서 사이클을 이루지 않는 최소 비용 간선(MST)을 선택
        1. 그래프의 간선들을 가중치의 오름차순으로 정렬한다.
        2. 정렬된 간선 리스트에서 순서대로 사이클을 형성하지 않는 간선을 선택한다.
            - 즉, 가장 낮은 가중치를 먼저 선택한다.
            - 사이클을 형성하는 간선을 제외한다.
        3. 해당 간선을 현재의 MST의 집합에 추가한다.
        - cycle 생성 여부 판단?
            - 그래프의 각 vertex에 set-id라는 것을 추가적으로 부여한다. 초기화 과정에서 모두 1~n까지의 값으로 각각의 vertex들을 초기화한다. 여기서 0은 어떠한 edge와도 연결되지 않았음을 의미하게 된다. 연결할 때마다 set-id를 하나로 통일시키는데, 값이 동일한 set-id개수가 많은 set-id값으로 통일시킨다
        - 시간복잡도
            - edge의 weight를 기준으로 정렬 - O(E log E)
            - cycle 생성 여부를 검사하고 set-id를 통일 - O(E + V log V)
    - **Prim Algorithm 프림 알고리즘**
        - 시작 정점에서부터 출발하여 신장 트리 집합을 단계적으로 확장해나가는 방법
        1. 시작 단계에서는 시작 정점이 MST 집합에 포함된다.
        2. 앞 단계에서 만들어진 MST 집합에 인접한 정점들 중에서 최소 간선으로 연결된 정점을 선택하여 트리를 확장한다. 가장 낮은 가중치를 먼저 선택한다.
        3. 위의 과정을 트리가 (N-1)개의 간선을 가질 때까지 반복한다.
        - 시간복잡도 O(E log V)
